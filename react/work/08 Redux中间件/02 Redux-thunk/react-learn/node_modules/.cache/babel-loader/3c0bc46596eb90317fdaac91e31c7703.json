{"ast":null,"code":"'use strict';\n\nconst escapeStringRegexp = require('escape-string-regexp');\nconst ansiStyles = require('ansi-styles');\nconst stdoutColor = require('supports-color').stdout;\nconst template = require('./templates.js');\nconst isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm');\n\n// `supportsColor.level` â†’ `ansiStyles.color[name]` mapping\nconst levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];\n\n// `color-convert` models to exclude from the Chalk API due to conflicts and such\nconst skipModels = new Set(['gray']);\nconst styles = Object.create(null);\nfunction applyOptions(obj, options) {\n  options = options || {};\n\n  // Detect level if not set manually\n  const scLevel = stdoutColor ? stdoutColor.level : 0;\n  obj.level = options.level === undefined ? scLevel : options.level;\n  obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;\n}\nfunction Chalk(options) {\n  // We check for this.template here since calling `chalk.constructor()`\n  // by itself will have a `this` of a previously constructed chalk object\n  if (!this || !(this instanceof Chalk) || this.template) {\n    const chalk = {};\n    applyOptions(chalk, options);\n    chalk.template = function () {\n      const args = [].slice.call(arguments);\n      return chalkTag.apply(null, [chalk.template].concat(args));\n    };\n    Object.setPrototypeOf(chalk, Chalk.prototype);\n    Object.setPrototypeOf(chalk.template, chalk);\n    chalk.template.constructor = Chalk;\n    return chalk.template;\n  }\n  applyOptions(this, options);\n}\n\n// Use bright blue on Windows as the normal blue color is illegible\nif (isSimpleWindowsTerm) {\n  ansiStyles.blue.open = '\\u001B[94m';\n}\nfor (const key of Object.keys(ansiStyles)) {\n  ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');\n  styles[key] = {\n    get() {\n      const codes = ansiStyles[key];\n      return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);\n    }\n  };\n}\nstyles.visible = {\n  get() {\n    return build.call(this, this._styles || [], true, 'visible');\n  }\n};\nansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), 'g');\nfor (const model of Object.keys(ansiStyles.color.ansi)) {\n  if (skipModels.has(model)) {\n    continue;\n  }\n  styles[model] = {\n    get() {\n      const level = this.level;\n      return function () {\n        const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);\n        const codes = {\n          open,\n          close: ansiStyles.color.close,\n          closeRe: ansiStyles.color.closeRe\n        };\n        return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);\n      };\n    }\n  };\n}\nansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), 'g');\nfor (const model of Object.keys(ansiStyles.bgColor.ansi)) {\n  if (skipModels.has(model)) {\n    continue;\n  }\n  const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);\n  styles[bgModel] = {\n    get() {\n      const level = this.level;\n      return function () {\n        const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);\n        const codes = {\n          open,\n          close: ansiStyles.bgColor.close,\n          closeRe: ansiStyles.bgColor.closeRe\n        };\n        return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);\n      };\n    }\n  };\n}\nconst proto = Object.defineProperties(() => {}, styles);\nfunction build(_styles, _empty, key) {\n  const builder = function () {\n    return applyStyle.apply(builder, arguments);\n  };\n  builder._styles = _styles;\n  builder._empty = _empty;\n  const self = this;\n  Object.defineProperty(builder, 'level', {\n    enumerable: true,\n    get() {\n      return self.level;\n    },\n    set(level) {\n      self.level = level;\n    }\n  });\n  Object.defineProperty(builder, 'enabled', {\n    enumerable: true,\n    get() {\n      return self.enabled;\n    },\n    set(enabled) {\n      self.enabled = enabled;\n    }\n  });\n\n  // See below for fix regarding invisible grey/dim combination on Windows\n  builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey';\n\n  // `__proto__` is used because we must return a function, but there is\n  // no way to create a function with a different prototype\n  builder.__proto__ = proto; // eslint-disable-line no-proto\n\n  return builder;\n}\nfunction applyStyle() {\n  // Support varags, but simply cast to string in case there's only one arg\n  const args = arguments;\n  const argsLen = args.length;\n  let str = String(arguments[0]);\n  if (argsLen === 0) {\n    return '';\n  }\n  if (argsLen > 1) {\n    // Don't slice `arguments`, it prevents V8 optimizations\n    for (let a = 1; a < argsLen; a++) {\n      str += ' ' + args[a];\n    }\n  }\n  if (!this.enabled || this.level <= 0 || !str) {\n    return this._empty ? '' : str;\n  }\n\n  // Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,\n  // see https://github.com/chalk/chalk/issues/58\n  // If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.\n  const originalDim = ansiStyles.dim.open;\n  if (isSimpleWindowsTerm && this.hasGrey) {\n    ansiStyles.dim.open = '';\n  }\n  for (const code of this._styles.slice().reverse()) {\n    // Replace any instances already present with a re-opening code\n    // otherwise only the part of the string until said closing code\n    // will be colored, and the rest will simply be 'plain'.\n    str = code.open + str.replace(code.closeRe, code.open) + code.close;\n\n    // Close the styling before a linebreak and reopen\n    // after next line to fix a bleed issue on macOS\n    // https://github.com/chalk/chalk/pull/92\n    str = str.replace(/\\r?\\n/g, `${code.close}$&${code.open}`);\n  }\n\n  // Reset the original `dim` if we changed it to work around the Windows dimmed gray issue\n  ansiStyles.dim.open = originalDim;\n  return str;\n}\nfunction chalkTag(chalk, strings) {\n  if (!Array.isArray(strings)) {\n    // If chalk() was called by itself or with a string,\n    // return the string itself as a string.\n    return [].slice.call(arguments, 1).join(' ');\n  }\n  const args = [].slice.call(arguments, 2);\n  const parts = [strings.raw[0]];\n  for (let i = 1; i < strings.length; i++) {\n    parts.push(String(args[i - 1]).replace(/[{}\\\\]/g, '\\\\$&'));\n    parts.push(String(strings.raw[i]));\n  }\n  return template(chalk, parts.join(''));\n}\nObject.defineProperties(Chalk.prototype, styles);\nmodule.exports = Chalk(); // eslint-disable-line new-cap\nmodule.exports.supportsColor = stdoutColor;\nmodule.exports.default = module.exports; // For TypeScript","map":null,"metadata":{},"sourceType":"script"}