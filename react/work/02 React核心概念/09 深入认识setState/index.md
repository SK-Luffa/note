# 深入认识setState

setState,它对状态的改变，可能是异步的 注意：可能 表示有可能是同步，也有可能是异步 不一定

> 如果改变状态的代码处于某个HTML元素的事件中，则其是异步的，否则是同步的

setState()方法的第二个参数是一个函数，这个函数是回调函数，既然是回调函数，那么一定是当setState执行完毕后才触发

在多次调用setState 的时候，由于它是异步的，那么就会导致每次执行实际上拿到的只是一个初始值，所以就算写一百个setState 和写一个setState 几乎没有什么区别，   
那么有人就会说，我们可以每次的setState写到上一个函数的第二个参数，也就是上一个函数的回调函数当中，但是这样的写法确实十分恶心 会不停的进行嵌套

* setState(prev=>{})   prev :表示当前的状态 该函数的返回结果，会混合（覆盖）掉之前的结果 该函数也是异步函数

* 例如：
  this.setState(cur => ({
  n: cur.n + 1
  }))
  this.setState(cur => ({
  n: cur.n + 1
  }))
  this.setState(cur => ({
  n: cur.n + 1
  }))

  此时 cur 会覆盖掉之前的结果 虽然是异步函数，但会形成队列，就会按顺序执行

    * 如果遇到某个事件中，需要同步调用多次，需要使用函数的方式得到最新的状态

  最佳实践：
    1. 把所有的setState当作是异步的(你心里明白这个实际上可能是是异步的就行)
    2. 永远不要信任setState调用之后的状态
    3. 如果要使用改变之后的状态，需要使用回调函数（setState的第二个参数）
    4. 如果新的状态要根据之前的状态进行运算，使用函数的方式改变状态（setState的第一个函数） prev

##### react会对异步的setState进行优化（只针对异步的setState），将多次setState进行合并（将多次状态改变完成之后，在统一对state进行改变，然后出发render） 所以这里就可以解释，为什么只触发了一次视图的更新

      所以是否可以解释异步的三个SetState没有进行回调函数或者prev 进行了合并，从而在内部实际上一百个执行最终会覆盖成一个