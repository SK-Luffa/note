# 接口和类型兼容性

# 扩展类型-接口
 
接口：inteface

>扩展类型： 类型别名、枚举、接口、类


TypeScript的接口：用于约束类、对象、函数的契约（标准）

契约（标准）的形式：
- API文档，弱标准
- 代码约束，强标准
 
 和类型别名一样，接口，不出现在编译结果中
 
1. 接口约束对象
2. 接口约束函数
   

**接口可以继承**
    
```TS
 interface A{
     T1:stirng
 }
 interface B extends A{
     T2:number
 }
 let u:B{
     T1:"123",
     T2:123
 }

interface C extends A,B{
    T3:boolean
}
 

```


可以通过接口之间的继承，实现多种接口的组合

使用类型别名可以实现类似的组合效果，需要通过 ```&``` ，它叫做交叉类型
```TS
type C={
    T3:boolean
}&A&B
```

上述两个（接口和类型别名）的区别是：
- 子接口不能覆盖父接口的成员（接口）
- 交叉类型会把相同成员的类型进行交叉



**readonly**

只读修饰符，修饰的目标是只读的（无法修改 ）
只读修饰符不在编译结果中

# 类型兼容性

B-A，如果能完成赋值，则B和A类型兼容

鸭子辨型法（子结构辨型法）：目标类型需要某一些特征，赋值的类型只要能满足该特征即可，而不需要考虑其他条件

- 基本类型：完全匹配

- 对象类型：鸭子辨型法


类型断言   as   


当直接使用对象字面量赋值的时候，会进行更加严格的判断 

- 函数类型 

**参数**：传递给目标函数的参数可以少，但不能多

**返回值**：要求返回值，就必须进行返回，并且类型必须匹配 ，如果不要求返回值，则无论返回不还回（包括类型），都不会做限制
