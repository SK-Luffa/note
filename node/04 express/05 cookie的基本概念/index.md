 # 一个不大不小的问题

* 假设服务器又一个接口，通过请求这个接口，可以添加一个管理员
* 但是，不是任何人都有权利做这种操作
* 那么服务器如何知道请求借口的人是有权利的呢？
  
* 答案是：只有登陆过的管理员才能做这种操作

* 可问题是，客户端和服务器的传输使用的是http协议，http协议是无状态的 ，什么是无状态？ 就是**服务器不知道这一次请求的人，跟之前登陆请求成功的人是不是同一个人** 

<img src='01.png'>


* 由于http协议的无状态，服务器**不会记得** 之前的所有请求，它无法确定这一次请求的客户端，就是之前登陆成功的那个客户端

> 你可以把服务器想象成有着严重脸盲症的大专哥，他没有办法分清楚跟他说话的人之前做过什么

* 于是他们想到一个办法

* 他们按照下面的流程来认证客户端的身份

1. 客户端登陆成功后，服务器会给客户端一个出入证（令牌 token）
2. 后续客户端的每次请求，都必须要附带这个出入证  （令牌 token）
  
  <img src='02.png'>

  服务器发扬了认证不认人的优良传统，就可以很轻松的识别身份了

  但是，用户不可能只在一个网站登录，于是客户端会收到来自各个网站的出入证，因此，就要求客户端要有一个类似卡包的东西，能够具备下面的功能

  1. **能够存放多个出入证** 这些出入证来自不同的网站，也可能是一个网站有多个出入证，分别用于出入不同的地方 
  2. **能够自动出示出入证** 客户端在访问不同的网站时，能过自动地把对应的出入证附带请求发送出去。
  3. **正确的出示出入证**   客户端不能将肯德基的出入证发送给麦当劳
  4. **管理出入证的有效期**  客户端要能自动的发现那些已经过期的出入证，并把它从卡包内移除
   
   能够满足上面所有要求的 就是cookie

   cookie类似于一个卡包，专门用于存放各种出入证，并有着一套机制来自动管理这些证件


# Cookie的组成
 cookie是浏览器中一个特有的概念，他就像浏览器的专属卡包，管理着各个网站的信息

 每个cookie其实就相当于是属于某个网站的卡片，它记录了一下这些信息：

 * key：键，比如 「身份编号」
 * value：值，比如大专哥的身份账号是「213131231231231231212312」，这有点像卡片的条形码，当然，它可以是任何信息
 * domain：域，表示这个cookie是属于那个网站的，比如 luffa.tech,表示这个cookie属于luffa.tech这个网站
 * path：路径，表示这个cookie是属于该网站的哪个基路径，就好比是同一家公司不同部门会颁发不同的出入证。比如 /news，表示这个cooki是属于/news这个路径的
 * secure：是否使用安全传输
 * expire：过期时间，表示该cookie在什么时间过期
  
  当浏览器发送一个请求时，它会瞄一眼自己的卡包，看看那些卡片适合附带捎给服务器，如果一个cookie**同时满足**以下条件，则这个cookie会被附带到请求中：

  * cookie没有过期
  * cookie中的域和这次请求的域是匹配的
    * 比如cookie中的域是 luffa.com 则可以匹配的请求域有：luffa.com、 www.luffa.com、blogs.luffa.com 等
    * 比如cookie中的域是 www.luffa.com 则只能匹配www.luffa.com这样的请求域
    * cookie是不在乎端口的，只要域匹配即可
  * cookie中请求的path和这次请求的path是匹配的
    *  比如cookie中的path是 /news  则可以匹配的请求路径是 /news、/news/details、/news/a/b/c 等 ，但不能匹配 /blogs
    *  如果path是/ 可以想象 匹配的就是所有路径
  * 验证cookie的安全传输
    * 如果cookie的secure的属性是 true，则请求协议必须是https，否则不会发送该cookie
    * 如果cookir的secure的属性是 false ，则请求可以是http，也可以是https
  
  如果一个cookie满足了上述的所有条件，那么浏览器就会自动的把cookie加入到这次请求中  

  具体方式是：**浏览器会将符合条件的cookie，自动放置到请求头当中**  ；例如，当我在浏览器中访问百度的时候，他在请求头中附带了下面的cookie：

  


  




